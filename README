episode 9: creating basic HTTP server
run "node_modules/spikes/node_http/run.bat" to start the server
then go to localhost:8080 to hit the server.

episode 10: test-driving HTTP server
Exports in node are how you expose functionality between modules.
If you do a "require" to get a module from another file, like
var server = require("./server.js"),
then you can do server.<exportName>() to call the function declared
as exports.<exportName> in the server.js file.
Still need to figure out how to get the test not to hang when the server code
creates a new http server and sits there waiting for a response.

episode 11: lots of learning
have to tell the server to close after running a test on it
things happen asynchronously so hard to tell the tests to wait while it's waiting for a response

Lessons Learned #1: CI with Git

episode 12: first client-server test
- have to pass a callback to the teardown for tests and make sure it's called
- stopping server in teardown

episode 13: a basic "Hello World" server
http://www.letscodejavascript.com/v1/early_access/ep13.html
- response you set in the request handler is accessible in tests
        (response.statusCode = 404;)
- doing an http.get in the test gives you a "request" object,
and you can set handlers on events for that request, like an "on response" function, here:
        var request = http.get("http://localhost:8080");
        request.on("response", function (response) {
            <whatever>
        });
- same goes for the response object you get back in the "response" handler of the request.
    i.e.
        response.on("data", function(chunk) {
            <whatever>
        };
- data returned on response.on("data", ...) handler is a "chunk" which ends up being a buffer.
We can get this as Text if we do response.setEncoding("utf8");

episode 14: polishing up the server
http://www.letscodejavascript.com/v1/early_access/ep14.html
- error handling - to verify that exceptions are thrown
    test.throws(function () {
        server.stop();
    });

episode 15: Enforce the node version
http://www.letscodejavascript.com/v1/early_access/ep15.html
- calling out to shell with:
  jake.createExec(command, { printStdout: true, printStderr: true });

episode 16: Make them read your crap
http://www.letscodejavascript.com/v1/early_access/ep16.html

episode 17: Minimum Marketable Feature
http://www.letscodejavascript.com/v1/early_access/ep17.html
- we don't have to shell out to get the current version of node. oops!
- a bunch of code was added to jakefile to verify node version number better.
- goal now:
    - serve a one-file homepage
    - serve 404 errors for everything else
    - be able to deploy
- created spike to prove we can serve a file instead of writing HTML to response directly
- need to test-drive this in the real server

episode 18: Test-Driven Files
http://www.letscodejavascript.com/v1/early_access/ep18.html
- to create a directory, you can use jake.
    first, call directory(<dir_name>); in the jakefile, and you can then
    use <dir_name> as a prerequisite for a jake task to get it to happen before that task is run.
- to remove a directory, call jake.rmRf(<dir_name>)
    - this is set up as a task in jakefile called "clean", so run "jake clean" to delete the temp directory.

episode 21: Checking our assumptions
- need to be better about handling errors
- still a weird problem when running the server through the command line: when you call server.stop() with
    correct parameters, it doesn't make the callback and seems to keep running, though if you tell it to stop again
    it will say it stopped.

episode 22: custom 404 page
- need to create a stand-alone server

episode 25: The Startup Race
- equivalent to console.log that doesn't put a line break at the end of the line is process.stdout.write
- need to have callback in server.start so it can let calling code know when the server is started.
    - server.listen takes such a callback! hooray!

episode 26: Child Killer
- we're not stopping the server using the server's built-in methods; we are just killing
    the node process that is hosting it.

episode 27: Smoked
- changed wikipaint.js to pass in command line parameter for Port # to the server.start() call.
     - port = process.argv[2];
- have minimal server up & running; moving on to other things next time

episode 28: Which Host?
- working on deploying the site to somewhere real
- deploying to heroku
    - uses 'foreman' to run the app in the same way heroku would
    - Foreman starts all the processes you need to run your app so you
        can run locally as though you had heroku running, and we can test
        our heroku deployment procfile
    - in smoke_test file, instead of running Node, run Foreman
    - Foreman needs a procfile that lists the process types in the app
        - https://devcenter.heroku.com/articles/nodejs#declare-process-types-with-procfile
        - line in procfile:
            web: node src/server/wikipaint.js $PORT
                - $PORT ends up being 5000 because that's just what Foreman uses
        - run "foreman start" and then browse to localhost:5000 and you'll see the app running
        - the output of Foreman is different from the usual node responses,
          so tests probably have to change

episode 29: I don't wanna use Foreman
- hard to get output of the foreman process to verify that it works and the
  procfile is correct. and the way to get it to work doesn't work on Windows.
  so we're going to parse the procfile and test that instead.
- at 10:00 through episode 29

episode 30: Parse the procfile

episode 31: deploying to heroku
- need a package.json file to be able for Heroku to know it's a node app

episode 32: to the web!
- deployed to http://mighty-hollows-6403.herokuapp.com
- wrote test to make sure site is up and running
- still lots of duplication in code (httpGet function all over)
- deployment not automated

episode 33: A Client-Side Test Tool
- want to have the first story be a single-user drawing app and then expand to multi-user later
- set up client-side testing
- test drawing tool (Raphael?)
- integrate into HTML page
- JS Test Driver?
- Testacular?
- start with testacular

episode 34: Cross-browser and cross-platform
- using Testacular to run tests using Mocha (testacular init)
- must check that we're testing against all browsers
- remove src/client/_*_test.js files from jakefile lists of tests
- run 'testacular start' to start. this means this browser is ready to run tests on the
  server port declared in testacular.conf.js
- need to install mocha ('npm install mocha') and chai (chaijs.com)  as an assertion framework
- to run, need to do "testacular start" and then "testacular run"
- these tests all run just like th eserver tests, but they're running in the browser!
- to get these tests to run in multiple browsers, we can open the testacular server in each of them
  and then re-run "testacular run".
- if you run these tests while looking at the browser, you'll see the browser output status
  of all the tests: for example,
      "
      IE 9.0 is idle
      IE 8.0 is idle
      Chrome 22.0 is idle
      Firefox 15.0 is idle"
  then you see, in the console, all the tests' output/assertions for all relevant browsers
- tests don't run on IE7 or IE8.

episode 35: IE Hate
- probably can't use Chai as assertion framework under Mocha. Going to try should.js
- later: can't use Should.js either. try Expect.js?
- after trying to get Expect working, it's hard to tell whether it's the right Expect.
- More next episode.

episode 36: great expectations
- "Expect" installed before was not the right expect. need to install "Expect.js".
- will use a BDD style on client testing.
- need to set up client-side linting options
- next: run testacular from jakefile

episode 37: just run jake
- remember, to run Testacular:
    - in one terminal session, run 'testacular.sh start'
    - open the server with whichever browsers, i.e.: http://localhost:8082
    - in another terminal, run "jake testClient"
- next time: set up automated build so client code is linted differently, and make sure
  all browsers are tested correctly on build.

episode 38: lint the client code
- at 8:31 in the video


to build:
    - run ./jake.sh