episode 9: creating basic HTTP server
run "node_modules/spikes/node_http/run.bat" to start the server
then go to localhost:8080 to hit the server.

episode 10: test-driving HTTP server
Exports in node are how you expose functionality between modules.
If you do a "require" to get a module from another file, like
var server = require("./server.js"),
then you can do server.<exportName>() to call the function declared
as exports.<exportName> in the server.js file.
Still need to figure out how to get the test not to hang when the server code
creates a new http server and sits there waiting for a response.

episode 11: lots of learning
have to tell the server to close after running a test on it
things happen asynchronously so hard to tell the tests to wait while it's waiting for a response

Lessons Learned #1: CI with Git

episode 12: first client-server test
- have to pass a callback to the teardown for tests and make sure it's called
- stopping server in teardown

episode 13: a basic "Hello World" server
http://www.letscodejavascript.com/v1/early_access/ep13.html
- response you set in the request handler is accessible in tests
        (response.statusCode = 404;)
- doing an http.get in the test gives you a "request" object,
and you can set handlers on events for that request, like an "on response" function, here:
        var request = http.get("http://localhost:8080");
        request.on("response", function (response) {
            <whatever>
        });
- same goes for the response object you get back in the "response" handler of the request.
    i.e.
        response.on("data", function(chunk) {
            <whatever>
        };
- data returned on response.on("data", ...) handler is a "chunk" which ends up being a buffer.
We can get this as Text if we do response.setEncoding("utf8");

episode 14: polishing up the server
http://www.letscodejavascript.com/v1/early_access/ep14.html
- error handling - to verify that exceptions are thrown
    test.throws(function () {
        server.stop();
    });

episode 15: Enforce the node version
http://www.letscodejavascript.com/v1/early_access/ep15.html
- calling out to shell with:
  jake.createExec(command, { printStdout: true, printStderr: true });

episode 16: Make them read your crap
http://www.letscodejavascript.com/v1/early_access/ep16.html

episode 17: Minimum Marketable Feature
http://www.letscodejavascript.com/v1/early_access/ep17.html
- we don't have to shell out to get the current version of node. oops!
- a bunch of code was added to jakefile to verify node version number better.
- goal now:
    - serve a one-file homepage
    - serve 404 errors for everything else
    - be able to deploy
- created spike to prove we can serve a file instead of writing HTML to response directly
- need to test-drive this in the real server

episode 18: Test-Driven Files
http://www.letscodejavascript.com/v1/early_access/ep18.html
- to create a directory, you can use jake.
    first, call directory(<dir_name>); in the jakefile, and you can then
    use <dir_name> as a prerequisite for a jake task to get it to happen before that task is run.
- to remove a directory, call jake.rmRf(<dir_name>)
    - this is set up as a task in jakefile called "clean", so run "jake clean" to delete the temp directory.

episode 21: Checking our assumptions
- need to be better about handling errors
- still a weird problem when running the server through the command line: when you call server.stop() with
    correct parameters, it doesn't make the callback and seems to keep running, though if you tell it to stop again
    it will say it stopped.

episode 22: custom 404 page
- need to create a stand-alone server


to build:
    - run ./jake.sh